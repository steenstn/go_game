<html>
    <head>
        <style>
            body {
                background-color: black;
            }
            canvas {
                border: 1px solid #eee
            }
        </style>
    </head>
 <body>
<canvas id="c"></canvas>
<pre id="output"></pre>
<script>
    "use strict";
    // #include "client/enums.js"
    // #include "client/constants.js"
    // #include "client/queue.js"

    let input = document.getElementById("input");
    let output = document.getElementById("output");
    let socket;
    let keysDown = new Set();
    let dt = 0;
    let lastFrame = new Date();

    let c = document.getElementById('c');
    c.width = window.innerWidth-50;
    c.height = window.innerHeight-50;
    let ctx = c.getContext('2d');

    let inputHistory = [];
    let requestNumber = 0;
    // #include "client/functions.js"
    // #include "client/input.js"

    let currentLevel = [];

    let viewportX = 0;
    let viewportY = 0;
    let playerX = 0;
    let playerY = 0;

    let animationCounter = 0;
    let animationFlag = 0;
    let direction = 0;

    let entities = [];


    let playerSpriteImage = new Image();
    let levelTilesetImage = new Image();

    let rx = [];
    let ry = [];
    for(let i = 0; i < 50; i++) {
        rx.push(Math.random()*c.width);
        ry.push(Math.random()*c.height);
    }

    let joinGame = () => {
        socket = new WebSocket("ws://localhost:8080/join");
        socket.onopen = function () {
            output.innerText += "Status: Connected\n";
        };

        socket.onmessage = function (e) {
            //console.log(atob(JSON.parse(e.data).Msg))

            let json = JSON.parse(e.data);
//            console.log("Type", json.Type)
            let type = JSON.parse(json.Type);
            let subType = JSON.parse(json.SubType);
            console.log("subtype", subType);
 //           console.log("type", type)
            let message = JSON.parse(atob(json.Msg));

            switch(type) {
                case GameUpdateMessage:
                    // TODO Do not reallocate this every time
                    entities = [];
                    for(let i = 0; i < message.length; i++) {
                        entities.push({x: message[i].X, y: message[i].Y});
                    }
                    break;
                case SetupMessage:
                    if(subType === SetupMessageSubType_Level) {
                        currentLevel = message;
                    } else if(subType === SetupMessageSubType_PlayerSprite) {
                        playerSpriteImage.src = 'data:image/png;base64,' + message;
                    } else if(subType === SetupMessageSubType_LevelTileset) {
                        levelTilesetImage.src = 'data:image/png;base64,' + message;
                    }
                    break;
                case PlayerPositionMessage:
                    playerX = message.X;
                    playerY = message.Y;
                    break;
                default:
                    throw "Unhandled type " + type;
            }
        };

        setupKeyListeners();
        setTimeout(gameLoop, 10);
    };


    let loadingLoop = () => {
        console.log("Loading stuff")
    }

    let rain = () => {
        for(let i = 0; i < 50; i++) {
            rx[i] = rx[i] + 2;
            ry[i] = ry[i] + 6;
            if(rx[i] > c.width) {
                rx[i] = 0;
            }
            if(ry[i] > c.height) {
                rx[i] = Math.random()*c.width;
                ry[i] = 0;
            }
            ctx.strokeStyle = "white";
            ctx.beginPath();
            ctx.moveTo(rx[i], ry[i]);
            ctx.lineTo(rx[i]+5, ry[i]+10);

            ctx.stroke();

        }
    }

    let gameLoop = () => {
        

        if(keysDown.has("ArrowLeft")) {
            playerX-=3;
            direction = 1;
        }
        if(keysDown.has("ArrowRight")) {
            playerX+=3;
            direction = 0;
        }
            ctx.fillStyle="#72727f";
            ctx.fillRect(0,0,c.width,c.height);
            let x = 0;
            let y = 0;

            // TODO: Optimize to only draw around the player
            let indexStart = getArrayIndex(50, 50, playerX, playerY);
            for(let i = indexStart; i < currentLevel.length; i++) {
                //ctx.fillStyle = currentLevel[i] == 0 ? "#fff" : "#000";
                ctx.fillStyle = currentLevel[i] == 0 ? "#000" : "#fff";
                if(currentLevel[i]=== 1) {
                    ctx.drawImage(levelTilesetImage, Math.floor(-viewportX + x), Math.floor(-viewportY + y));
                }
                //ctx.fillRect(Math.floor(-viewportX + x), Math.floor(-viewportY + y), 50, 50);
                x+=50;
                if(x >= 100*50) {
                    x = 0;
                    y +=50;
                }

            }

        
        ctx.fillStyle = "#fff";
        for(let i = 0; i < entities.length; i++) {
            ctx.drawImage(playerSpriteImage, 0+20*animationFlag,0+30*direction, 20,30,-viewportX+entities[i].x-5, -viewportY+entities[i].y-20,30,30);
            //ctx.fillRect(-viewportX + entities[i].x, -viewportY + entities[i].y, 10, 10);
        }
                // Stop viewport from going outside of level (50*50 and 50*20 is level dimensions)
                viewportX = Math.max(1, playerX-c.width/2);
                viewportX = Math.min(50*100-(c.width),viewportX);
                viewportY = Math.max(1, playerY-c.height/2);
                viewportY = Math.min(50*20-(c.height),viewportY);

        animationCounter++;
        if (animationCounter > 5) {
            animationCounter = 0;
            animationFlag = 1 - animationFlag;
        }
        //ctx.drawImage(playerSpriteImage, 10,10);
        setTimeout(gameLoop, 50);

        //requestAnimationFrame(gameLoop);
    }


    joinGame();

</script>
    </body>
</html>
