<html>
    <head>
        <style>
            body {
                background-color: black;
            }
            canvas {
                border: 1px solid #eee
            }
        </style>
    </head>
 <body>
<canvas id="c"></canvas>
<pre id="output"></pre>
<script>
    "use strict";
// client/enums.js
const EntityType_Player = 0;
const EntityType_Fly = 1;
const EntityType_Spider = 2;
const MessageType_GameUpdateMessage = 0;
const MessageType_SetupMessage = 1;
const MessageType_PlayerPositionMessage = 2;
const SetupMessageSubType_Level = 0;
const SetupMessageSubType_PlayerSprite = 1;
const SetupMessageSubType_LevelTileset = 2;
// client/queue.js
// Circular array queue
class Queue {
    
    constructor(size) {
        this.size = size;
        this.data = new Array(size);
        this.tail = 0;
        this.head = 0;
        this.numEntries = 0;
    }

    // Push a value. Pushing past the capacity overwrites the oldest value
    push(value) {
        if(this.numEntries >= this.data.length) {
            this.head = (this.head + 1) % (this.data.length);
        }
        this.data[this.tail] = value;
        this.tail = (this.tail + 1) % this.data.length;
        this.numEntries++;
        return true;
    }

    pop() {
        if(this.numEntries <=0) {
            return null;
        }
        let value = this.data[this.head];
        this.head = (this.head + 1) % (this.data.length);
        this.numEntries--;
        return value;
    }
}
// client/spider.js
// https://www.researchgate.net/publication/220632147_FABRIK_A_fast_iterative_solver_for_the_Inverse_Kinematics_problem

let armLength = 50;

let distance = (a, b) => {
    return Math.sqrt((a.x - b.x)*(a.x-b.x) + (a.y - b.y)*(a.y-b.y));
};

let getDistancesBetweenPoints = (points) => {
  let distances = []
  for(let i = 0; i < points.length-1; i++) {
    distances.push(distance(points[i], points[i+1]));
  }
  return distances;
}

let easeOutQuad = (progress) => {
    return 1 - (1 - progress) * (1 - progress);
}

let lerp = (startValue, endValue, progress) => {
    return startValue + (endValue - startValue) * progress
}

let fabrik = (positions, distancesBetweenJoints, target) => {
  let distanceToTarget = distance(positions[0], target);
  let jointDistanceSum = distancesBetweenJoints.reduce( (a,b) => {return a+b}, 0);
  if (distanceToTarget > jointDistanceSum) { // Target unreachable
    for(let i = 0; i < positions.length-1; i++) {
      let r = distance(target, positions[i]);
      let delta = distancesBetweenJoints[i]/r;
      positions[i+1].x = (1-delta)*positions[i].x+delta*target.x;
      positions[i+1].y = (1-delta)*positions[i].y+delta*target.y;
    }
  } else {
    let bx = positions[0].x;
    let by = positions[0].y;
    let diff = distance(positions[positions.length-1], target);
    for(let iter = 0; iter < 3; iter++) {
      // Stage 1: Forward reaching
      positions[positions.length-1].x = target.x;
      positions[positions.length-1].y = target.y;

      for(let i = positions.length-2; i >=0; i--) {
        let r = distance(positions[i+1], positions[i]);
        let delta = distancesBetweenJoints[i]/r;
        positions[i].x = (1-delta)*positions[i+1].x+delta*positions[i].x;
        positions[i].y = (1-delta)*positions[i+1].y+delta*positions[i].y;
      }

      // Stage 2: Backward reaching
      positions[0].x = bx;
      positions[0].y = by;
    
      for(let i = 0; i < positions.length-2; i++) {
        let r = distance(positions[i+1], positions[i]);
        let delta = distancesBetweenJoints[i]/r;
        positions[i+1].x = (1-delta)*positions[i].x + delta*positions[i+1].x;
        positions[i+1].y = (1-delta)*positions[i].y + delta*positions[i+1].y;
      }
      diff = distance(positions[positions.length-1], target);
    }
  }

}

/*
 This method drags to the target. No fix point
 */
let fabrik2 = (positions, distancesBetweenJoints, target) => {
  let distanceToTarget = distance(positions[0], target);
  let jointDistanceSum = distancesBetweenJoints.reduce( (a,b) => {return a+b}, 0);
  let bx = positions[0].x;
  let by = positions[0].y;
  let diff = distance(positions[positions.length-1], target);

  positions[positions.length-1].x = target.x;
  positions[positions.length-1].y = target.y;

  for(let i = positions.length-2; i >=0; i--) {
    let r = distance(positions[i+1], positions[i]);
    let delta = distancesBetweenJoints[i]/r;
    positions[i].x = (1-delta)*positions[i+1].x+delta*positions[i].x;
    positions[i].y = (1-delta)*positions[i+1].y+delta*positions[i].y;
  }
}

class Spider {
  constructor(startX, startY) {
    this.arms = [];
    this.distances = [];
    this.targets = [];
    let numArms = 3;
    let arm_length = 30;
    for(let i = 0; i < numArms; i++) {
      let arm = [{x: startX, y:startY}];
      for(let j =1; j<=3;j++) {
        arm.push({x:startX+40+j*arm_length,y:startY+j*arm_length});
      }
      this.arms.push(arm);
      this.distances.push(getDistancesBetweenPoints(arm))
      this.targets.push({x:this.arms[i][numArms-1].x+i*40, y:this.arms[i][numArms-1].y+40});
    }
    this.body = this.arms[0][0];
  }

  moveBody(x, y) {
    this.arms.forEach(arm => {
      arm[0].x = x;
      arm[0].y = y;
    })
  }
}

let updateTargets = (targets, origin) => {
  targets.forEach((t, i) => {
    let normalizedI = i-(targets.length/2)+0.5;
    //
    //console.log(i, normalizedI)
    if(Math.abs(t.x+20*normalizedI -origin.x) > 90) {
      let diff = t.x - origin.x;
      t.x-=diff*1.5;
    }
  });
}

/*
 
0 1 2 3 4


-1 -0.5 0 0.5 1


 */
let getNewTargets = (targets, origin) => {
  // TODO allocate right away
  let newTargets = [];

  targets.forEach((t, i) => {
      let normalizedI = i/(targets.length);
      let optimalDiff = origin.x-40+normalizedI*150;
      let diff = origin.x-t.x;
        newTargets.push({x:optimalDiff, y:400});
  });
  return newTargets;
}

/*
 Interpolate between p0, p1, p2 with with t = 0-1
 */
let bezier = (t, p0, p1, p2) => {
  return (1-t)*((1-t)*p0 + t*p1) + t*((1-t)*p1 +t*p2);
}


// client/render.js

let renderPlayer = (viewportX, viewportY, x, y, direction, context, image, animationFlag) => {
  context.drawImage(image, 0+20*animationFlag,0+30*direction, 20,30,-viewportX+x-5, -viewportY+y-20,30,30);
}

    let input = document.getElementById("input");
    let output = document.getElementById("output");
    let socket;
    let keysDown = new Set();
    let lastFrame = new Date();

    let c = document.getElementById('c');
    c.width = window.innerWidth-50;
    c.height = window.innerHeight-50;
    let ctx = c.getContext('2d');

    let inputHistory = [];
    let requestNumber = 0;
// client/functions.js

let getArrayIndex = (levelWidth, tileWidth, x, y) => {
    return Math.floor(x/tileWidth)+Math.floor(y/tileWidth)*levelWidth;
  }
// client/input.js
let convertKeyPressesToByte = (input) => {
   let buttonsPressed =
        (1 & (input.has("ArrowUp")? 1 : 0) ) |
        (2 & (input.has("ArrowDown")? 2 : 0)) |
        (4 & (input.has("ArrowLeft")? 4 : 0)) |
        (8 & (input.has("ArrowRight")? 8 : 0));
    return new Uint8Array([buttonsPressed]);
}

let sendKeys = () =>  {
    let input = convertKeyPressesToByte(keysDown);
    let data = {Num: requestNumber, Input: input[0]};
    inputHistory.push(data);
    requestNumber++;

    socket.send(JSON.stringify(data));
}

let pressKey = (key) => {
    keysDown.add(key);
    sendKeys();
}

let releaseKey = (key) => {
    keysDown.delete(key);
    sendKeys();
};

let setupKeyListeners = () => {
    addEventListener("keydown", (e) => {
        pressKey(e.key);
    }, false);

    addEventListener("keyup", (e) => {
        releaseKey(e.key);
    }, false)
};


    let currentLevel = [];

    let viewportX = 0;
    let viewportY = 0;
    let playerX = 0;
    let playerY = 0;

    let animationCounter = 0;
    let animationFlag = 0;
    let direction = 0;
    let moving = 0;

    //let spider = new Spider(200,200);
    let leg = [];
    for(let i = 0; i < 10; i++) {
      leg.push({x:100+10*i, y:100+10*i});
    }
    let dists = getDistancesBetweenPoints(leg);


    let entities = [];


    let playerSpriteImage = new Image();
    let levelTilesetImage = new Image();

    let rx = [];
    let ry = [];
    for(let i = 0; i < 50; i++) {
        rx.push(Math.random()*c.width);
        ry.push(Math.random()*c.height);
    }

    let joinGame = () => {
        socket = new WebSocket("ws://localhost:8080/join");
        socket.onopen = function () {
            output.innerText += "Status: Connected\n";
        };

        socket.onmessage = function (e) {
            //console.log(atob(JSON.parse(e.data).Msg))

            let json = JSON.parse(e.data);
            let type = JSON.parse(json.Type);
            let subType = JSON.parse(json.SubType);
            ////console.log("subtype", subType);
            let message = JSON.parse(atob(json.Msg));

            switch(type) {
                case MessageType_GameUpdateMessage:
                    // TODO Do not reallocate this every time
                    entities = [];
            //console.log(message)
                    for(let i = 0; i < message.Positions.length; i++) {
                        entities.push({x: message.Positions[i].X, y: message.Positions[i].Y, type: message.Types[i]});
                    }
                    break;
                case MessageType_SetupMessage:
                    if(subType === SetupMessageSubType_Level) {
                        currentLevel = message;
                    } else if(subType === SetupMessageSubType_PlayerSprite) {
                        playerSpriteImage.src = 'data:image/png;base64,' + message;
                    } else if(subType === SetupMessageSubType_LevelTileset) {
                        levelTilesetImage.src = 'data:image/png;base64,' + message;
                    }
                    break;
                case MessageType_PlayerPositionMessage:
                    playerX = message.X;
                    playerY = message.Y;
                    break;
                default:
                    throw "Unhandled type " + type;
            }
        };

        setupKeyListeners();
        setTimeout(gameLoop, 10);
    };


    let loadingLoop = () => {
        console.log("Loading stuff")
    }

    let rain = () => {
        for(let i = 0; i < 50; i++) {
            rx[i] = rx[i] + 2;
            ry[i] = ry[i] + 6;
            if(rx[i] > c.width) {
                rx[i] = 0;
            }
            if(ry[i] > c.height) {
                rx[i] = Math.random()*c.width;
                ry[i] = 0;
            }
            ctx.strokeStyle = "white";
            ctx.beginPath();
            ctx.moveTo(rx[i], ry[i]);
            ctx.lineTo(rx[i]+5, ry[i]+10);

            ctx.stroke();

        }
    }

    let gameLoop = () => {
        
        if(keysDown.has("ArrowLeft")) {
            //playerX-=3;
            //direction = 1;
        }
        if(keysDown.has("ArrowRight")) {
            //playerX+=3;
            //direction = 0;
        }
            ctx.fillStyle="#7CC9ED";
            ctx.fillRect(0,0,c.width,c.height);
            let x = 0;
            let y = 0;

            // TODO: Optimize to only draw around the player
            let indexStart = getArrayIndex(50, 50, playerX, playerY);
            for(let i = 0; i < currentLevel.length; i++) {
                //ctx.fillStyle = currentLevel[i] == 0 ? "#fff" : "#000";
                ctx.fillStyle = currentLevel[i] == 0 ? "#000" : "#fff";
                if(currentLevel[i]=== 1) {
                    ctx.drawImage(levelTilesetImage, Math.floor(-viewportX + x), Math.floor(-viewportY + y));
                }
              
                //ctx.fillText(""+currentLevel[i], Math.floor(-viewportX + x+20), Math.floor(-viewportY + y+20));
                //ctx.fillRect(Math.floor(-viewportX + x), Math.floor(-viewportY + y), 50, 50);
                x+=50;
                if(x >= 100*50) {
                    x = 0;
                    y +=50;
                }

            }

        
        ctx.fillStyle = "#fff";
        for(let i = 0; i < entities.length; i++) {
          if(entities[i].type === EntityType_Player) {
              //ctx.drawImage(playerSpriteImage, 0+20*animationFlag,0+30*direction, 20,30,-viewportX+entities[i].x-5, -viewportY+entities[i].y-20,30,30);
              renderPlayer(viewportX, viewportY, entities[i].x, entities[i].y, direction, ctx, playerSpriteImage, animationFlag);
          } else if (entities[i].type === EntityType_Fly) {
              ctx.fillStyle = "#000";
              ctx.fillRect(-viewportX + entities[i].x, -viewportY + entities[i].y, 3, 3);
              ctx.fillStyle = "#ddd";
              ctx.fillRect(-viewportX + entities[i].x+4, -viewportY + entities[i].y-3*Math.random()+1*Math.random(), 4, 4);
              ctx.fillRect(-viewportX + entities[i].x-4, -viewportY + entities[i].y-3*Math.random()+1*Math.random(), 4, 4);

          } else if (entities[i].type === EntityType_Spider) {
              //ctx.fillRect(-viewportX + entities[i].x, -viewportY + entities[i].y, 40, 10);

            fabrik2(leg,dists,entities[i]);
            for(let legIndex = 0; legIndex < leg.length; legIndex++) {
              let index = getArrayIndex(50, 50, leg[legIndex].x, leg[legIndex].y);
              if(currentLevel[index] !== 1) {
                leg[legIndex].y+=2;
              }
            }
            ctx.beginPath();
            leg.forEach(l => {
              ctx.lineTo(-viewportX + l.x, -viewportY + l.y);
              //ctx.fillRect(-viewportX + l.x,-viewportY +  l.y, 40, 10);
            });
            ctx.stroke();
            
              //spider.move2(entities[i].x, entities[i]);
              //spider.update();
              //spider.render(ctx,-viewportX, -viewportY);
          }

        }
        // Stop viewport from going outside of level (50*50 and 50*20 is level dimensions)
        viewportX = Math.max(1, playerX-c.width/2);
        viewportX = Math.min(50*100-(c.width),viewportX);
        viewportY = Math.max(1, playerY-c.height/2);
        viewportY = Math.min(50*20-(c.height),viewportY);

        animationCounter++;
        if (animationCounter > 5) {
            animationCounter = 0;
            animationFlag = 1 - animationFlag;
        }
        //ctx.drawImage(playerSpriteImage, 10,10);
        setTimeout(gameLoop, 50);

        //requestAnimationFrame(gameLoop);
    }


    joinGame();

</script>
    </body>
</html>
