<html>
    <head>
        <style>
            body {
                background-color: black;
            }
            canvas {
                border: 1px solid #eee
            }
        </style>
    </head>
 <body>
<canvas id="c"></canvas>
<pre id="output"></pre>
<script>
    "use strict";
const EntityType_Player = 0;
const EntityType_Fly = 1;
const EntityType_Spider = 2;
const MessageType_GameUpdateMessage = 0;
const MessageType_SetupMessage = 1;
const MessageType_PlayerPositionMessage = 2;
const SetupMessageSubType_Level = 0;
const SetupMessageSubType_PlayerSprite = 1;
const SetupMessageSubType_LevelTileset = 2;
// Circular array queue
class Queue {
    
    constructor(size) {
        this.size = size;
        this.data = new Array(size);
        this.tail = 0;
        this.head = 0;
        this.numEntries = 0;
    }

    // Push a value. Pushing past the capacity overwrites the oldest value
    push(value) {
        if(this.numEntries >= this.data.length) {
            this.head = (this.head + 1) % (this.data.length);
        }
        this.data[this.tail] = value;
        this.tail = (this.tail + 1) % this.data.length;
        this.numEntries++;
        return true;
    }

    pop() {
        if(this.numEntries <=0) {
            return null;
        }
        let value = this.data[this.head];
        this.head = (this.head + 1) % (this.data.length);
        this.numEntries--;
        return value;
    }
}
// https://www.researchgate.net/publication/220632147_FABRIK_A_fast_iterative_solver_for_the_Inverse_Kinematics_problem

let armLength = 50;
class Spider {
  constructor(startX, startY) {
    this.arms = [
      new Arm(startX, startY),
      new Arm(startX+50, startY),
      new Arm(startX+100, startY),
      new Arm(startX+150, startY),
    ]

    for(let i = 0; i < this.arms.length; i++) {
      this.arms[i].segments[0].x = 200;
      this.arms[i].segments[0].y = 300;
    }

  }

  x() {
    return this.arms[0].segments[0].x;
  }

  y() {
    return this.arms[0].segments[0].y;
  }

  move(x, y) {
    for(let i = 0; i < this.arms.length; i++) {
      let arm = this.arms[i];
      for(let j = 0; j < arm.segments.length; j++) {
        arm.segments[j].x+=x;
        arm.segments[j].y+=y;
      }
    }
  }

  move2(x, y) {
    for(let i = 0; i < this.arms.length; i++) {
      let arm = this.arms[i];
        let oldX = arm.segments[0].x;
        let oldY = arm.segments[0].y;
        arm.segments[0].x=x;
        arm.segments[0].y=y;
      for(let j = 1; j < arm.segments.length; j++) {
        arm.segments[j].x+=arm.segments[0].x-oldX;
        arm.segments[j].y+=arm.segments[0].y-oldY;
      }
      }
  }

  update() {
    for(let armIndex = 0; armIndex < this.arms.length; armIndex++) {
        let arm = this.arms[armIndex];
        let arms = arm.segments;
        if(Math.abs(arms[0].x - arm.p2.x) > 50) {
            arm.target2.x = arms[0].x -80;
            arm.p0 = {x: arm.target.x, y: arm.target.y};
            arm.p1 = {x: arm.p0.x-arm.reach/2, y: arm.p0.y-arm.rise};
            arm.p2 = {x: arm.p0.x-arm.reach, y: arm.target2.y};
            arm.t=0;
        }
        if(Math.abs(arms[0].x - arm.p2.x) > 50) {
            arm.target2.x = arms[0].x - 80;
            arm.p0 = {x: arm.target.x, y: arm.target.y};
            arm.p1 = {x: arm.p0.x+arm.reach/2, y: arm.p0.y-arm.rise};
            arm.p2 = {x: arm.p0.x+arm.reach, y: arm.target2.y};
            arm.t=0;
        }

        ctx.fillStyle = "#000";

        let bx = bezier(arm.t, arm.p0.x, arm.p1.x, arm.p2.x);
        let by = bezier(arm.t, arm.p0.y, arm.p1.y, arm.p2.y);

        arm.target.x = bx;
        arm.target.y = by;
        if(arm.t <1) {
            arm.t+=0.1;
        }

        let dist = distance(arm.target, arms[0]);

        if(dist > (arms.length)*armLength) {
            for(let i = 0; i < arms.length - 1; i++) {
                let r = distance(arm.target, arms[i]);
                let delta = armLength/r;
                arms[i+1].x = (1-delta) * arms[i].x + delta*arm.target.x;
                arms[i+1].y = (1-delta) * arms[i].y + delta*arm.target.y;
            }
        } else {
            let bx = arms[0].x;
            let by = arms[0].y;
            let max = 500;
            let iterations = 0;
            let diff = distance(arms[arms.length-1], arm.target);
            while (diff > 2 && iterations < max) {
                iterations++;
                arms[arms.length-1].x = arm.target.x;
                arms[arms.length-1].y = arm.target.y;
                for(let i = arms.length-2; i >=0; i--) {
                    let r = distance(arms[i+1], arms[i]);
                    let delta = armLength/r;
                    arms[i].x = (1-delta)*arms[i+1].x + delta*arms[i].x;
                    arms[i].y = (1-delta)*arms[i+1].y + delta*arms[i].y;
                }

                arms[0].x = bx;
                arms[0].y = by;
                for(let i = 0; i < arms.length-1; i++) {
                    let r = distance(arms[i+1], arms[i]);
                    let delta = armLength/r;
                    arms[i+1].x = (1-delta)*arms[i].x + delta*arms[i+1].x;
                    arms[i+1].y = (1-delta)*arms[i].y + delta*arms[i+1].y;
                }
                diff = distance(arms[arms.length-1], arm.target);
            }

        }

        // Rotation check
/*
        for(let i=0; i < arms.length-2; i++) {
            let angle = Math.atan2(arms[i+1].y-arms[i].y, arms[i+1].x-arms[i].x);
            let angle2 = Math.atan2(arms[i+2].y-arms[i].y, arms[i+2].x-arms[i].x);
            ctx.fillText(""+ (angle*(180/Math.PI)), arms[i].x+20, arms[i].y )
            ctx.fillText(""+ (angle2*(180/Math.PI)), arms[i].x+20, arms[i].y+20 )
        }
    */


        if(false) {

            ctx.fillStyle= "#0f0";
            ctx.fillRect(arm.target.x, arm.target.y, 10,10);
            ctx.fillStyle= "#060";
            ctx.fillRect(arm.target2.x, arm.target2.y, 10,10);
            ctx.fillStyle= "#06f";
            ctx.fillText("arm.target2", arm.target2.x, arm.target2.y);
        }
    }
  }

  render(context, offsetX, offsetY) {
    console.log("aaaa");
    context.fillRect(offsetX+50, offsetY+50,100,100);
    for(let armIndex = 0; armIndex < this.arms.length; armIndex++) {
        let arm = this.arms[armIndex];
        let arms = arm.segments;
        for(let i=0; i < arms.length-1; i++) {
            context.fillStyle = "#a00";
            context.fillRect(offsetX+arms[i].x,offsetY+arms[i].y,5,5);
            context.fillStyle= "#000";
            context.fillText(""+ i, offsetX+arms[i].x, offsetY+arms[i].y )
            context.beginPath();
            context.moveTo( offsetX+arms[i].x, offsetY+arms[i].y);
            context.lineTo(offsetX+arms[i+1].x, offsetY+arms[i+1].y);
            context.stroke();
        }
    }
  }

}

class Arm {
    constructor(startX, startY) {
        this.segments = [
            new ArmSegment(50),
            new ArmSegment(50),
            new ArmSegment(50),
            new ArmSegment(50)
        ]
        this.t=0;
        this.target = {x: startX, y: startY};
        this.target2 = {x: this.target.x, y: this.target.y};
        this.rise = 60;
        this.reach = 120;
        this.p0 = {x: this.target2.x, y:this.target2.y};
        this.p1 = {x: this.target2.x, y:this.target2.y};
        this.p2 = {x: this.target2.x, y:this.target2.y};
    }
};

class ArmSegment {
    constructor(length) {
        this.x = 0;
        this.y = 0;
        this.length = length;
    }
};


let distance = (a, b) => {
    return Math.sqrt((a.x - b.x)*(a.x-b.x) + (a.y - b.y)*(a.y-b.y));
};

/*
 Interpolate between p0, p1, p2 with with t = 0-1
 */
let bezier = (t, p0, p1, p2) => {
  return (1-t)*((1-t)*p0 + t*p1) + t*((1-t)*p1 +t*p2);
}



    let input = document.getElementById("input");
    let output = document.getElementById("output");
    let socket;
    let keysDown = new Set();
    let lastFrame = new Date();

    let c = document.getElementById('c');
    c.width = window.innerWidth-50;
    c.height = window.innerHeight-50;
    let ctx = c.getContext('2d');

    let inputHistory = [];
    let requestNumber = 0;
let convertKeyPressesToByte = (input) => {
   let buttonsPressed =
        (1 & (input.has("ArrowUp")? 1 : 0) ) |
        (2 & (input.has("ArrowDown")? 2 : 0)) |
        (4 & (input.has("ArrowLeft")? 4 : 0)) |
        (8 & (input.has("ArrowRight")? 8 : 0));
    return new Uint8Array([buttonsPressed]);
}

let getArrayIndex = (levelWidth, tileWidth, x, y) => {
    let xPos = Math.floor(x / tileWidth);
    let yPos = levelWidth * Math.floor(y/tileWidth);
    let res = Math.floor(xPos + yPos);
    if(res < 0) {
        res = 0;
    }
    return 0;
}
let sendKeys = () =>  {
    let input = convertKeyPressesToByte(keysDown);
    let data = {Num: requestNumber, Input: input[0]};
    inputHistory.push(data);
    requestNumber++;

    socket.send(JSON.stringify(data));
}

let pressKey = (key) => {
    keysDown.add(key);
    sendKeys();
}

let releaseKey = (key) => {
    keysDown.delete(key);
    sendKeys();
};

let setupKeyListeners = () => {
    addEventListener("keydown", (e) => {
        pressKey(e.key);
    }, false);

    addEventListener("keyup", (e) => {
        releaseKey(e.key);
    }, false)
};


    let currentLevel = [];

    let viewportX = 0;
    let viewportY = 0;
    let playerX = 0;
    let playerY = 0;

    let animationCounter = 0;
    let animationFlag = 0;
    let direction = 0;
    let moving = 0;

    let spider = new Spider(200,200);

    let entities = [];


    let playerSpriteImage = new Image();
    let levelTilesetImage = new Image();

    let rx = [];
    let ry = [];
    for(let i = 0; i < 50; i++) {
        rx.push(Math.random()*c.width);
        ry.push(Math.random()*c.height);
    }

    let joinGame = () => {
        socket = new WebSocket("ws://localhost:8080/join");
        socket.onopen = function () {
            output.innerText += "Status: Connected\n";
        };

        socket.onmessage = function (e) {
            //console.log(atob(JSON.parse(e.data).Msg))

            let json = JSON.parse(e.data);
            let type = JSON.parse(json.Type);
            let subType = JSON.parse(json.SubType);
            console.log("subtype", subType);
            let message = JSON.parse(atob(json.Msg));

            switch(type) {
                case MessageType_GameUpdateMessage:
                    // TODO Do not reallocate this every time
                    entities = [];
            console.log(message)
                    for(let i = 0; i < message.Positions.length; i++) {
                        entities.push({x: message.Positions[i].X, y: message.Positions[i].Y, type: message.Types[i]});
                    }
                    break;
                case MessageType_SetupMessage:
                    if(subType === SetupMessageSubType_Level) {
                        currentLevel = message;
                    } else if(subType === SetupMessageSubType_PlayerSprite) {
                        playerSpriteImage.src = 'data:image/png;base64,' + message;
                    } else if(subType === SetupMessageSubType_LevelTileset) {
                        levelTilesetImage.src = 'data:image/png;base64,' + message;
                    }
                    break;
                case MessageType_PlayerPositionMessage:
                    playerX = message.X;
                    playerY = message.Y;
                    break;
                default:
                    throw "Unhandled type " + type;
            }
        };

        setupKeyListeners();
        setTimeout(gameLoop, 10);
    };


    let loadingLoop = () => {
        console.log("Loading stuff")
    }

    let rain = () => {
        for(let i = 0; i < 50; i++) {
            rx[i] = rx[i] + 2;
            ry[i] = ry[i] + 6;
            if(rx[i] > c.width) {
                rx[i] = 0;
            }
            if(ry[i] > c.height) {
                rx[i] = Math.random()*c.width;
                ry[i] = 0;
            }
            ctx.strokeStyle = "white";
            ctx.beginPath();
            ctx.moveTo(rx[i], ry[i]);
            ctx.lineTo(rx[i]+5, ry[i]+10);

            ctx.stroke();

        }
    }

    let gameLoop = () => {
        
        if(keysDown.has("ArrowLeft")) {
            //playerX-=3;
            //direction = 1;
        }
        if(keysDown.has("ArrowRight")) {
            //playerX+=3;
            //direction = 0;
        }
            ctx.fillStyle="#7CC9ED";
            ctx.fillRect(0,0,c.width,c.height);
            let x = 0;
            let y = 0;

            // TODO: Optimize to only draw around the player
            let indexStart = getArrayIndex(50, 50, playerX, playerY);
            for(let i = indexStart; i < currentLevel.length; i++) {
                //ctx.fillStyle = currentLevel[i] == 0 ? "#fff" : "#000";
                ctx.fillStyle = currentLevel[i] == 0 ? "#000" : "#fff";
                if(currentLevel[i]=== 1) {
                    ctx.drawImage(levelTilesetImage, Math.floor(-viewportX + x), Math.floor(-viewportY + y));
                }
                //ctx.fillRect(Math.floor(-viewportX + x), Math.floor(-viewportY + y), 50, 50);
                x+=50;
                if(x >= 100*50) {
                    x = 0;
                    y +=50;
                }

            }

        
        ctx.fillStyle = "#fff";
        for(let i = 0; i < entities.length; i++) {
        if(entities[i].type === EntityType_Player) {
            ctx.drawImage(playerSpriteImage, 0+20*animationFlag,0+30*direction, 20,30,-viewportX+entities[i].x-5, -viewportY+entities[i].y-20,30,30);
        } else if (entities[i].type === EntityType_Fly) {
            ctx.fillStyle = "#000";
            ctx.fillRect(-viewportX + entities[i].x, -viewportY + entities[i].y, 3, 3);
            ctx.fillStyle = "#ddd";
            ctx.fillRect(-viewportX + entities[i].x+4, -viewportY + entities[i].y-3*Math.random()+1*Math.random(), 4, 4);
            ctx.fillRect(-viewportX + entities[i].x-4, -viewportY + entities[i].y-3*Math.random()+1*Math.random(), 4, 4);

        } else if (entities[i].type === EntityType_Spider) {
            ctx.fillRect(-viewportX + entities[i].x, -viewportY + entities[i].y, 40, 10);
            spider.move2(entities[i].x, entities[i]);
            spider.update();
            spider.render(ctx,-viewportX, -viewportY);
          console.log("wee");
        }

        }
                // Stop viewport from going outside of level (50*50 and 50*20 is level dimensions)
            viewportX = Math.max(1, playerX-c.width/2);
            viewportX = Math.min(50*100-(c.width),viewportX);
            viewportY = Math.max(1, playerY-c.height/2);
            viewportY = Math.min(50*20-(c.height),viewportY);

        animationCounter++;
        if (animationCounter > 5) {
            animationCounter = 0;
            animationFlag = 1 - animationFlag;
        }
        //ctx.drawImage(playerSpriteImage, 10,10);
        setTimeout(gameLoop, 50);

        //requestAnimationFrame(gameLoop);
    }


    joinGame();

</script>
    </body>
</html>
